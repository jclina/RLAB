---
title: "Introduction to Advanced R"
subtitle: "Applying R to Lifestyle and Brain Health Research"
author: "Brian C. Helsel, PhD"
institute: "University of Kansas Medical Center"
date: today
format:
  revealjs:
    theme: [default, "../../styles/styleReveal.scss", customReveal.scss]
    slide-number: true
    preview-links: auto
    logo: https://brand.ku.edu/sites/brand/files/styles/wide_col_xl_6/public/images/2020/KUMarksLogo.png
    footer: "R for Lifestyle and Brain Health (R-LAB)"
    transition: slide
    background-transition: fade
    highlight-style: github
    code-line-numbers: true
    code-block-bg: true
    incremental: false
    date-format: long
    embed-resources: true
---

## R as a Language: More Than Just Stats {.title-slide}

::: {.highlight-box}
**R is a language and environment for statistical computing and graphics**

:::

**You will advance your R skills related to:**

- Research Software Engineering
- Building Packages and Reports
- Creating Dashboards and Web Apps

::: notes

This course isnâ€™t about using Râ€™s data analysis tools, but by strengthening your
understanding of R as a programming language, youâ€™ll gain deeper insight into
how those tools workâ€”and how to use them more effectively.

:::


## Getting Started {.pattern-dots}

::: {.columns}
::: {.column width="60%"}
**Installation Requirements:**

- **Base R**: Core language
- **Integrated development environment (IDE)**

::: {.tip-box}
ðŸ’¡ **Tip**: Common Integrated Development Environments Options Include R Studio, Positron, and Visual Studio Code.
:::
:::

::: {.column width="40%"}
**Essential Packages:**

| Package | Purpose |
|---------|---------|
| lobstr | Understanding R Objects |
| tibble | A Modern Data Frame |
| dplyr | Data wrangling |

:::
:::

::: notes

To get started with our lessons, you'll need to have R installed, along with an
integrated development environment (IDE).

Common IDEs include RStudio, Positron, and Visual Studio Code. Each has
different strengths:
â€“ RStudio is popular for R-specific workflows and ease of use
â€“ VS Code is more customizable and good for multi-language projects
â€“ Positron (if you're using it) is a lightweight option for quick scripting

For our first few lessons, make sure you install the following packages:
â€“ lobstr â€“ to explore how R manages objects in memory
â€“ tibble â€“ a modern, tidyverse-friendly version of data frames
â€“ dplyr â€“ for efficient data wrangling and manipulation

Youâ€™ll also want to create a GitHub account and install GitHub Desktop. This
will make it easier to access course materials, track your code, and eventually
build your own R packages or Shiny apps.

:::


## Binding Basics

```{r}
#| echo: true

library(lobstr)
x <- c(1, 2, 3)
obj_addr(x)

```

![](https://adv-r.hadley.nz/diagrams/name-value/binding-1.png){width="35%" .nostretch}


::: {.highlight-box}

Behind the scenes R creates a vector object of values `c(1, 2, 3)` and binds it
to a name `x` with an object address of **`r obj_addr(x)`**.

:::

. . .

```{r}
#| echo: true

# Creates another binding to the same object
y <- x
obj_addr(y)

```

![](https://adv-r.hadley.nz/diagrams/name-value/binding-2.png){width="35%" .nostretch}

## Copy-on-modify

```{r}
#| echo: true

y[[3]] <- 4
obj_addr(y)

```

Modifying `y` creates a new object that is a copy of **`r obj_addr(x)`**
and has a new object address of **`r obj_addr(y)`**.

![](https://adv-r.hadley.nz/diagrams/name-value/binding-3.png){width="35%" .nostretch}

We can see when an object gets copied with `base::tracemem()`

```{r}
#| echo: true
#| eval: false

y <- x
tracemem(x)
y[[3]] <- 4
untracemem(x)

```

```{r}
# echo: false

paste0("<", obj_addr(x), ">")

```

```{r}
# echo: false

paste0("tracemem[", obj_addr(x), " -> ", obj_addr(y), "]:")

```

## Function Calls {.pattern-grid}

The same rules for copying apply to function calls.

```{r}
#| echo: true
#| eval: false

f <- function(a) {
    a
}

tracemem(x)

z <- f(x)

untracemem(x)

```

![](https://adv-r.hadley.nz/diagrams/name-value/binding-f1.png){width="40%" .nostretch}

```{r}
# echo: false

paste0("<", obj_addr(x), ">")

```

Once `f()` completes, `x` and `z` will point to the same object.

![](https://adv-r.hadley.nz/diagrams/name-value/binding-f2.png){width="35%" .nostretch}

```{r}
# echo: false

f <- function(a) {
    a
}

z <- f(x)

paste0("tracemem[", obj_addr(x), " -> ", obj_addr(z), "]:")

```

## Lists

Elements of lists can also point to objects, but copy-on-modify differs from
variables in that a **shallow copy** is created.

```{r}
#| echo: true

l1 <- list(1, 2, 3)

```

A list stores references to the values rather than the values. This is important
to know for understanding what happens when we modify a list.

![](https://adv-r.hadley.nz/diagrams/name-value/list.png){width="40%" .nostretch}

```{r}
#| echo: true

l2 <- l1

```

![](https://adv-r.hadley.nz/diagrams/name-value/l-modify-1.png){width="40%" .nostretch}

```{r}
#| echo: true

l2[[3]] <- 4

```

![](https://adv-r.hadley.nz/diagrams/name-value/l-modify-2.png){width="40%" .nostretch}

Using the `ref()` function from the `lobstr` package shows the shared bindings across `l1` and `l2`.

```{r}
#| echo: true

ref(l1, l2)

```

## Data frames {.pattern-dots}

Data frames are lists of vectors and copy-on-modify works differently for columns and rows.

```{r}
#| echo: true

d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))

```

**Columns**

Only the modified column is changed.

```{r}
#| echo: true

d2 <- d1
d2[, 2] <- d2[, 2] * 2

```

::: {.columns}
::: {.column width="50%"}
![](https://adv-r.hadley.nz/diagrams/name-value/dataframe.png){width="60%" .nostretch}
:::
::: {.column width="50%"}
![](https://adv-r.hadley.nz/diagrams/name-value/d-modify-c.png){width="70%" .nostretch}
:::
:::

**Rows**

Every column is modified and must be copied.

```{r}
#| echo: true

d3 <- d1
d3[1, ] <- d3[1, ] * 3

```

![](https://adv-r.hadley.nz/diagrams/name-value/d-modify-r.png){width="70%" .nostretch}

